:q
w
let w = foldr f 0 [0 .. 10]
let w = foldr 0 f [0 .. 10]
z
let z = foldl f 0 [1..10]
f 1 2
let f = \x y -> x + y
x
main
:m -Main
:r
:m -Main
main
x
:r
:m - Main
:m - M1
:m - temp
:m - temp.hs
:m -*
:r
:m - 
:module temp.hs
:r
:m 
:m
:r
:l temp.hs
:l temp.hs
:l temp.hs
:q
:l temp.hs 
:l temp.hs 
:}
    addStr x y = x ++ y
let addStr :: String -> String -> String
:{
print "hahaha"
:q
show "42"
respondPalindromes "ABCBA"
respondPalindromes "ABBA"
respondPalindromes "uuu"
respondPalindromes "yesh uye"
:l palindrom.hs 
:}
      fmap f (Node x lub rub) = Node (f x) (fmap f lub) (fmap f rub)
      fmap _ Nill = Nill
                                             where
instance Functor Tree
:{
:}
      deriving (Eq, Ord, Show, Read)
      | Node x (Tree x) (Tree x)
      = Nill
data Tree x
:{
Tree Nill
:}
      deriving (Eq, Ord, Show, Read)
      | Node x (Tree x) (Tree x)
      = Nill
data Tree x
:{
:q
:q
exit
:?
:q
f 1
f = \x -> x+1
f = \x x+1
f = \x?
:q
insert 1 (B)
:}
      insert = S
      empty = B
instance Container Stack where
:{
insert 1 (B)
S 1 (B)
S 1 (S B)
insert 1 (S B)
inser 1 (S B)
:}
      insert x xs = S x xs
      empty = B
instance Container Stack where
:{
:}
      insert x xs = S x xs
      empty = B
instance Container S where
:{
:}
      insert :: a -> c a -> c a
      empty :: c a
class Container c where
