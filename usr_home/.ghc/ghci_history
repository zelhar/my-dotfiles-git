:q
insert 1 (B)
:}
      insert = S
      empty = B
instance Container Stack where
:{
insert 1 (B)
S 1 (B)
S 1 (S B)
insert 1 (S B)
inser 1 (S B)
:}
      insert x xs = S x xs
      empty = B
instance Container Stack where
:{
:}
      insert x xs = S x xs
      empty = B
instance Container S where
:{
:}
      insert :: a -> c a -> c a
      empty :: c a
class Container c where
:{
S 1 B
:}
      insert x xs = S x xs
      empty = B
instance Container S where
:{
:t (:)
:t insert
:}
    pairS xs ys = xs >>= \x -> ys >>= \y -> pure (x, y)
let pairS :: Stack a -> Stack b -> Stack (a, b)
:{
:}
      (>>=) (S x xs) g = combine (g x) (xs >>= g)
      (>>=) B _ = B
instance Monad Stack where
:{
:}
      (<*>) (S g gs) (xs) = combine (fmap g xs) (gs <*> xs)
      (<*>) (S g B) xs = fmap g xs
      (<*>) _ B = B
      (<*>) B _ = B
      pure x = S x B
instance Applicative Stack where
:{
:}
    combine (S x xs) ys = S x (combine xs ys)
    combine xs B = xs
    combine B ys = ys
let combine :: Stack a -> Stack a -> Stack a
:{
:}
      fmap g (S x xs) = S (g x) (fmap g xs)
      fmap _ B = B
instance Functor Stack where
:{
:}
      deriving (Eq, Ord, Show, Read)
      | S x (Stack x)
      = B
data Stack x
:{
:kind! []
:t []
:}
      deriving (Eq, Ord, Show, Read)
      | Node x (Tree x) (Tree x)
      = Nill
data Tree x
:{
:q
exit
x :: Int
:q
pairS s l
:}
    pairS xs ys = xs >>= \x -> ys >>= \y -> pure (x, y)
let pairS :: Stack a -> Stack b -> Stack (a, b)
:{
:}
      (>>=) (S x xs) g = combine (g x) (xs >>= g)
      (>>=) B _ = B
instance Monad Stack where
:{
s
gs <*> s
show (+)
gs
gs = S (+1) (S (*3) B)
combine s l
l
l = S 4 (S 5 (S 6 (S 7 B)))
:}
